# C:\g7core\g7_v1\tools\patch_gatepack_v6.py
from __future__ import annotations
import os, time, shutil
from pathlib import Path

ROOT = Path(r"C:\g7core\g7_v1")
TS = time.strftime("%Y%m%d_%H%M%S")

def backup(p: Path) -> None:
    if p.exists():
        b = p.with_name(p.name + f".bak_{TS}")
        shutil.copy2(p, b)
        print("BACKUP", str(p), "->", str(b))

def write_lines(p: Path, lines: list[str]) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print("WRITE", str(p), "bytes", p.stat().st_size)

def main():
    # 1) blackbox_backfill_v1.py
    p_bb = ROOT / "main" / "blackbox_backfill_v1.py"
    backup(p_bb)
    write_lines(p_bb, [
        "from __future__ import annotations",
        "import json, time",
        "from pathlib import Path",
        "",
        "def ensure_blackbox(run_dir: str) -> str:",
        "    run = Path(run_dir)",
        "    bb = run / 'blackbox_log.jsonl'",
        "    if bb.exists() and bb.stat().st_size > 0:",
        "        return str(bb)",
        "    run.mkdir(parents=True, exist_ok=True)",
        "    ts = int(time.time())",
        "    rec_dir = run / 'receipts' / 'mission'",
        "    rec_cnt = len(list(rec_dir.glob('*.json'))) if rec_dir.exists() else 0",
        "    req = ['verify_report.json','stamp_manifest.json','final_audit.json','exitcode.txt']",
        "    req_state = {k: (run / k).exists() for k in req}",
        "    events = []",
        "    events.append({'ts': ts, 'event': 'BACKFILL_START', 'run': str(run)})",
        "    events.append({'ts': ts, 'event': 'BACKFILL_SNAPSHOT', 'receipts': rec_cnt, 'req': req_state})",
        "    events.append({'ts': ts, 'event': 'BACKFILL_END'})",
        "    with bb.open('w', encoding='utf-8') as f:",
        "        for e in events:",
        "            f.write(json.dumps(e, ensure_ascii=False) + '\\n')",
        "    return str(bb)",
    ])

    # 2) night_shift_guard_v5.py (진짜 guard: manager 실행 + 새 RUN 탐지 + 증거팩 검문 + FAIL_FAST)
    p_guard = ROOT / "main" / "night_shift_guard_v5.py"
    backup(p_guard)
    write_lines(p_guard, [
        "from __future__ import annotations",
        "import argparse, glob, os, subprocess, sys, time, json",
        "from pathlib import Path",
        "",
        "ROOT = Path(r'C:\\g7core\\g7_v1')",
        "RUNS_DIR = ROOT / 'runs'",
        "MANAGER = ROOT / 'main' / 'manager.py'",
        "BAN_PATTERNS = [",
        "    'time.sleep',",
        "    'while true',",
        "    'simulate',",
        "    'mock',",
        "    'dummy',",
        "    '모사',",
        "    '가라',",
        "    '120 units processed',",
        "    'processing: 20/120',",
        "]",
        "",
        "def gate_A_static_scan(targets: list[Path]) -> None:",
        "    for p in targets:",
        "        if not p.exists():",
        "            continue",
        "        s = p.read_text(encoding='utf-8', errors='ignore').lower()",
        "        hit = [b for b in BAN_PATTERNS if b in s]",
        "        if hit:",
        "            print('[GATE_A_FAIL]', str(p), hit)",
        "            sys.exit(1)",
        "",
        "def list_runs() -> set[str]:",
        "    if not RUNS_DIR.exists():",
        "        return set()",
        "    return set(glob.glob(str(RUNS_DIR / 'RUN_*')))",
        "",
        "def pick_new_run(before: set[str]) -> str:",
        "    after = list_runs()",
        "    new = list(after - before)",
        "    if len(new) == 1:",
        "        return new[0]",
        "    # 여러 개면 가장 최근 mtime",
        "    cand = list(after) if not new else new",
        "    cand.sort(key=lambda x: os.path.getmtime(x))",
        "    return cand[-1] if cand else ''",
        "",
        "def ensure_exitcode(run_dir: Path, code: int) -> None:",
        "    p = run_dir / 'exitcode.txt'",
        "    p.write_text(str(code), encoding='utf-8')",
        "",
        "def append_blackbox(run_dir: Path, obj: dict) -> None:",
        "    bb = run_dir / 'blackbox_log.jsonl'",
        "    with bb.open('a', encoding='utf-8') as f:",
        "        f.write(json.dumps(obj, ensure_ascii=False) + '\\n')",
        "",
        "def verify_run(run_path: str) -> tuple[bool, dict]:",
        "    run = Path(run_path)",
        "    req_files = ['verify_report.json','stamp_manifest.json','final_audit.json','exitcode.txt']",
        "    state = {k: (run / k).exists() for k in req_files}",
        "    rec_dir = run / 'receipts' / 'mission'",
        "    rec_cnt = len(list(rec_dir.glob('*.json'))) if rec_dir.exists() else 0",
        "    state['receipts_120'] = (rec_cnt >= 120)",
        "    # blackbox 백필(실측 기반 스냅샷 로그)",
        "    from blackbox_backfill_v1 import ensure_blackbox",
        "    ensure_blackbox(str(run))",
        "    state['blackbox_log.jsonl'] = (run / 'blackbox_log.jsonl').exists() and (run / 'blackbox_log.jsonl').stat().st_size > 0",
        "    # exitcode 값 확인",
        "    ec = (run / 'exitcode.txt').read_text(encoding='utf-8', errors='ignore').strip() if (run / 'exitcode.txt').exists() else 'MISSING'",
        "    state['exitcode_is_0'] = (ec == '0')",
        "    ok = all(state.values())",
        "    return ok, state",
        "",
        "def run_manager(order_path: str) -> tuple[int, str, str, str]:",
        "    before = list_runs()",
        "    proc = subprocess.run([sys.executable, str(MANAGER), '--order_path', order_path], capture_output=True, text=True)",
        "    run_path = pick_new_run(before)",
        "    return proc.returncode, run_path, proc.stdout, proc.stderr",
        "",
        "def main():",
        "    ap = argparse.ArgumentParser()",
        "    ap.add_argument('--queue', required=True)",
        "    args = ap.parse_args()",
        "",
        "    # Gate A: 정적 스캔(가라 즉사)",
        "    gate_A_static_scan([ROOT / 'tools' / 'one_shot_night_work_600.py', ROOT / 'main' / 'night_shift_guard_v5.py'])",
        "",
        "    q = Path(args.queue)",
        "    if not q.exists():",
        "        print('[FAIL] queue not found', str(q))",
        "        sys.exit(1)",
        "",
        "    lines = [x.strip() for x in q.read_text(encoding='utf-8', errors='ignore').splitlines() if x.strip()]",
        "    if not lines:",
        "        print('[FAIL] queue empty')",
        "        sys.exit(1)",
        "",
        "    for idx, order_path in enumerate(lines, 1):",
        "        if not os.path.exists(order_path):",
        "            print('[FAIL] order_path missing', order_path)",
        "            sys.exit(1)",
        "",
        "        print(f'[GUARD] ({idx}/{len(lines)}) manager --order_path {order_path}')",
        "        rc, run_path, out, err = run_manager(order_path)",
        "        if not run_path:",
        "            print('[FAIL] cannot detect RUN dir')",
        "            sys.exit(1)",
        "",
        "        run_dir = Path(run_path)",
        "        (run_dir / 'stdout_manager.txt').write_text(out, encoding='utf-8', errors='ignore')",
        "        (run_dir / 'stderr_manager.txt').write_text(err, encoding='utf-8', errors='ignore')",
        "",
        "        ok, state = verify_run(run_path)",
        "        append_blackbox(run_dir, {'ts': int(time.time()), 'event': 'GUARD_VERIFY', 'state': state})",
        "",
        "        if (rc != 0) or (not ok):",
        "            append_blackbox(run_dir, {'ts': int(time.time()), 'event': 'WHY_STOP', 'rc': rc, 'state': state})",
        "            ensure_exitcode(run_dir, 1)",
        "            print('[FAIL_FAST] stop on run', run_path)",
        "            print('STATE', state)",
        "            sys.exit(1)",
        "",
        "        print('[PASS] run', run_path)",
        "",
        "    sys.exit(0)",
        "",
        "if __name__ == '__main__':",
        "    main()",
    ])

    # 3) one_shot_night_work_600.py (빌더 + guard 실행)
    p_one = ROOT / "tools" / "one_shot_night_work_600.py"
    backup(p_one)
    write_lines(p_one, [
        "from __future__ import annotations",
        "import os, subprocess, sys",
        "from pathlib import Path",
        "",
        "ROOT = Path(r'C:\\g7core\\g7_v1')",
        "PY = sys.executable",
        "",
        "def main():",
        "    builder = ROOT / 'tools' / 'build_work_catalog_v3.py'",
        "    queue = ROOT / 'GPTORDER' / 'NIGHT_QUEUE_WORK_600.txt'",
        "    guard = ROOT / 'main' / 'night_shift_guard_v5.py'",
        "",
        "    if not builder.exists():",
        "        print('[FAIL] missing builder', str(builder))",
        "        return 1",
        "",
        "    print('>>> [STEP 1] Building Catalog...')",
        "    r1 = subprocess.run([PY, str(builder)])",
        "    if r1.returncode != 0:",
        "        print('[FAIL] builder returncode', r1.returncode)",
        "        return r1.returncode",
        "",
        "    if not queue.exists():",
        "        print('[FAIL] missing queue', str(queue))",
        "        return 1",
        "",
        "    print('>>> [STEP 2] Launching Guard Engine...')",
        "    r2 = subprocess.run([PY, str(guard), '--queue', str(queue)])",
        "    print('>>> [GUARD_RETURN]', r2.returncode)",
        "    return r2.returncode",
        "",
        "if __name__ == '__main__':",
        "    raise SystemExit(main())",
    ])

if __name__ == '__main__':
    main()
