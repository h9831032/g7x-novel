### ▶ 단계 판정

**[확장 단계]**

형아 질문 2개로 쪼개서 냉정하게 답할게.

## 1) “2동작 → 3동작”으로 늘리는 거 가능하냐?

가능은 한데, **3동작을 기본값으로 깔면 터질 확률이 확 올라가.**
그래서 정답은 이거야:

* **기본값: 2동작**(수정 1 + 검증/리포트 1)
* **3동작은 ‘조건부’로만**(실패/경고/특정 모듈일 때만)

3동작 예시(안 터지게)

1. 수정(코드/설정)
2. 검증(테스트/DoD 체크)
3. 커밋/스냅샷/롤백(결과 확정 처리) ← **조건부**

즉, 3동작을 “매번”이 아니라 “필요할 때만” 쓰는 게 운영 정답.

---

## 2) “나처럼 숫자 언어 쓰는 사람 있냐?”

있어. 이름만 다를 뿐 **업계에선 흔한 방식**이야.

사람들이 이렇게 부름:

* **상태코드/에러코드**(숫자로 PASS/WARN/FAIL 나눔)
* **이벤트 로그 스키마**(고정 필드, ENUM ID)
* **프로토콜/패킷**(정해진 숫자/코드로 통신)
* **DSL(작은 전용 언어)**, **opcode(명령 코드)**

즉, 형아가 하려는 건 “특이한 발명”이 아니라
**공장/시스템 운영에서 검증된 정석 패턴**을 G6X에 맞춰 “봉인”하려는 거야.

---

## 확장 단계 설계 제안 (A/B)

### (A) 보수안(추천)

* 숫자 언어 도입하되
* **2동작 기본 + 3동작 조건부**
* 48로 1~2회 무사고 확인 → 60으로 상승

### (B) 공격안

* 60부터 바로 가고
* 3동작도 일부 케이스에서 바로 적용(수정→검증→커밋)
  **이 설계는 위험하지만, 현재 단계에서는 감당 가능함.**
  위험: 3동작이 “슬쩍 4동작”으로 늘어나면서 제미나이가 멍청해지고 누락/혼선 증가

---

## 파괴력 있는 구조적 아이디어 1개(위험 포함)

**“마이크로-오퍼레이션(µOP) 세트”**를 만들어서
동작을 1,2,3이 아니라 **‘조립식’으로 딱 6개 정도만** 허용해버리는 거야.

예:

* µ1=EDIT, µ2=VERIFY, µ3=REPORT, µ4=SNAPSHOT, µ5=ROLLBACK, µ6=COMMIT
  이 조합만 허용하면 3동작도 안전하게 확장됨.
  위험: 처음엔 자유도가 줄어서 답답할 수 있음(하지만 운영은 안정해짐).

---

**치매방지 1줄(초딩버전)**
숫자 언어는 흔한 “공장 표준 방식”이고, 3동작도 가능하지만 기본은 2동작으로 가고 3동작은 필요할 때만 쓰는 게 안 터진다.
### ▶ 단계 판정

**[확장 단계]**

형아 질문에 바로 답: **넣어야 한다.**
단, **지금 당장 “풀세트 µOP”**가 아니라, **최소 6개만** 먼저 봉인해서 운영 규율로 쓰는 게 정답이야. (감리/설계 입장에서)

왜냐면 형아 목표가 “48→60→120”으로 커지는 구조고, 그때 제일 터지는 게
**“동작이 슬쩍 늘어나서(2→3→4) 제미나이가 멍청해지고, 누락/섞임이 생기는 사고”**거든.
µOP는 그 사고를 “물리적으로 못 하게” 막는 장치야.

---

## 내가 리딩하는 결론: “µOP 최소형 v0”는 필수

### 지금 바로 봉인할 최소 µOP 6개(이걸로 끝)

* µ1 EDIT : 수정(코드/설정)
* µ2 VERIFY : 테스트/검증 실행
* µ3 REPORT : 영수증/요약/로그 기록
* µ4 SNAPSHOT : 스냅샷 저장
* µ5 ROLLBACK : 되돌리기
* µ6 COMMIT : 확정 반영

규칙(감리 핵심)

* **기본 2동작 = EDIT + VERIFY**
* **3동작은 조건부 = + (REPORT 또는 SNAPSHOT/COMMIT/ROLLBACK 중 1개만)**
* 한 작업에서 µOP는 **최대 3개**(4개부터는 자동 FAIL)

이렇게 하면 형아가 말한 “동작 늘리기”를 해도 **안 터짐.**

---

## 왜 “넣어야 하는가” (핵심 3줄)

1. **동작 폭주를 막는다**: 2동작이 4동작으로 커지는 순간부터 사고율 폭증
2. **하청 품질이 일정해진다**: 제미나이가 뭘 해야 하는지 선택지가 줄어들어 실수 감소
3. **회귀/감사에 강해진다**: 같은 µOP 조합이면 결과 비교가 쉬워져서 버그 추적이 빨라짐

---

## 단, 공격적으로 하면 위험한 부분(확장 단계 규칙)

(A) 보수안(추천)

* µOP 6개만 도입
* 최대 3개 제한
* 48에서 무사고 2회 후 60으로

(B) 공격안

* µOP를 12개 이상으로 늘리고 세분화(EDIT_SPLIT, VERIFY_FAST 등)
  **이 설계는 위험하지만, 현재 단계에서는 감당 가능함.**
  위험: 코드북이 커지면서 “사투리/매핑 실수”가 늘어남

---

## 바로 실행 가능한 “봉인 형태”

* `sortlang_codebook_v1.json`에 µOP(action_id)를 고정 추가
* validator 규칙:

  * action_count > 3 → INVALID
  * action_seq에 EDIT가 없는데 COMMIT 있으면 → INVALID
  * VERIFY 없이 COMMIT이면 → INVALID (기본 정책)

이러면 형아는 신경 안 써도 **자동으로 통제**된다.

---

**치매방지 1줄(초딩버전)**
µOP는 “해야 할 행동 종류를 6개로 제한하는 안전장치”라서, 48→60→120으로 커질수록 꼭 필요하고 최소 6개만 먼저 봉인해서 2동작 기본·3동작 조건부로 굴리면 안 터진다.
### ▶ 단계 판정

**[확장 단계]**

오케이. “기존 방식 vs 마이크로OP(µOP) 방식” 차이점이랑 장단점 **딱 핵심만** 정리할게.

---

## 1) 차이점(초딩 버전)

### 기존 방식

* “가서 알아서 해” 스타일
* 제미나이가 **어떤 행동을 몇 번 할지** 마음대로 늘릴 수 있음
* 그래서 2동작 시켰는데 실제로는 4동작이 되는 일이 생김

### µOP 방식

* “리모컨 버튼 6개만 눌러” 스타일
* 행동이 **EDIT/VERIFY/REPORT/SNAPSHOT/ROLLBACK/COMMIT** 안에서만 움직임
* 한 작업은 **최대 2~3번 버튼만** 누르게 제한

---

## 2) 장점(µOP 방식이 이기는 점)

1. **사고 줄어듦**

* “몰래 동작 늘어나서 꼬임”이 크게 줄어

2. **누락 줄어듦**

* VERIFY(검사) 같은 걸 버튼으로 강제하니까 “검사 빼먹기”가 줄어

3. **망했을 때 복구가 빨라짐**

* SNAPSHOT/ROLLBACK이 표준 행동이라 되돌리기 쉬움

4. **60개 운영이 편해짐**

* 형아가 목표로 잡은 60을 “꾸준히” 돌리기 좋아짐

---

## 3) 단점(µOP 방식의 비용)

1. **자유도가 줄어듦**

* 제미나이가 “즉흥적으로 이것저것” 못 함
* 어떤 케이스는 “한 번에 해결”이 아니라 2번에 나눠야 함

2. **초기에 세팅 비용이 듦**

* 버튼(µOP) 정의 + 규칙(최대 3동작 등) 한 번 봉인해야 함
* 이게 귀찮음(근데 한 번만 하면 끝)

3. **규칙이 너무 빡세면 진행이 느려질 수 있음**

* 예: 무조건 VERIFY 강제인데 테스트가 느리면 전체가 느려짐
* 그래서 VERIFY를 “빠른 검증/필수 검증”으로 나누거나 조건부로 해야 함

---

## 4) 결론(형아 목표 60 기준)

* 형아가 “120까지 무리 안 해도 된다, 60 안정이 목표”라면
  ✅ **µOP 방식이 더 잘 맞음**
  왜냐면 속도 몇 %가 아니라 **사고율을 줄여서 체감 효율을 올리는 장치**라서.

---

**치매방지 1줄(초딩버전)**
기존은 “알아서 해”라서 동작이 몰래 늘어 사고가 나고, µOP는 “버튼 6개만+최대 3번”이라 자유도는 줄지만 60개를 안정적으로 굴리기 훨씬 좋아진다.
### ▶ 단계 판정

**[확장 단계]**

### ✅ 프로젝트 파일 우선 참조 근거 1줄

어제까지 “만차 24(12+12) + 줄자(meter_tick) OK”와 “다음 해야 할 5시간 코스/미해결(NEG_02 오탐, MeterGuard INVALID 격리 자동화, 만차 발주기)”가 **`/mnt/data/12.28개발일지.txt`**에 정리돼 있음.

---

## 0) 형아가 오늘 “오케이”한 합의(내가 책임지고 이대로 리딩)

1. **바로 60부터 시작**(12×5 서브팩)
2. **µOP는 8개 허용**, **10개는 금지**
3. 기본은 **2동작(수정+검증)**, 3동작은 **조건부**(보고/스냅샷/확정/되돌리기/중단 중 1개만)
4. “모델 2개(15+15) 병렬 운영”은 **금지 유지**(운영 복잡도가 먼저 터짐)
   근거: `/mnt/data/12.28개발일지.txt` 결정사항에 금지로 박혀있음

---

## 1) 기존 방식 vs µOP 방식 차이(오늘 작업에 직접 연결되는 포인트만)

* 기존: “알아서 해”라서 2동작 시켰는데 실제론 4동작이 되어 **폭주/누락/꼬임** 발생
* µOP: 버튼이 8개로 고정이라 **동작이 몰래 늘어나는 걸 물리적으로 차단**
  그래서 60을 “꾸준히” 굴리는 운영에 맞음

---

## 2) 오늘 할 일 최적 순서(퇴근 후 5시간 코스, 그대로 따라가면 됨)

### Step 1) 30분: 바닥 영수증(현재가 멀쩡한지) 한 번 더 찍기

* 목적: “60 올리다가 문제 나면, 24가 멀쩡했다” 기준점이 있어야 디버그가 쉬움
* 실행

  * `python tools/run_bundle_v4.py`
* DoD

  * `Total Tasks: 24 | Subpacks: 2 | REALCALL Used: ...` 유지
  * meter_tick에 `workitem_count: 12`, `meter_status: OK`, `evidence_status: VERIFIED` 찍힘
  * 근거 형식은 `/mnt/data/12.28개발일지.txt`에 이미 예시로 박제됨

### Step 2) 60분: 만차를 60으로 확장(12×5)

* 목표: “12개씩만 먹이는 보호”는 유지하면서, **총량만 60으로** 올림
* 해야 할 것(코드)

  * `tools/run_bundle_v4.py`를 **옵션 추가**로 확장(새 파일 만들지 말고 최소 변경 추천)
  * 추가 옵션 예시

    * `--total_tasks 60`
    * `--subpack_size 12`
* DoD

  * 출력이 이렇게 바뀌어야 함

    * `Total Tasks: 60 | Subpacks: 5 | ...`
  * 마지막 꼬다리(예: 60이 아닌 숫자 넣었을 때 남는 잔여)는 자동으로 “마지막 서브팩” 처리

### Step 3) 90분: µOP 8개 “코드북 + 검증기” 봉인(오늘 핵심)

* µOP 8개(고정)

  * EDIT, VERIFY, REPORT, SNAPSHOT, ROLLBACK, COMMIT, PLAN, ABORT
* 규칙(감리 규칙, 오늘 바로 박음)

  1. workitem 당 µOP는 **최대 3개**(4개부터 INVALID 격리)
  2. **COMMIT은 VERIFY 없이 금지**
  3. ABORT 나오면 해당 workitem은 **즉시 중단 + 격리 기록**
* 어디에 박냐(최소 변경 원칙)

  * workitem manifest(작업 지시서)에 `ops:[...]` 필드 추가
  * meter_tick에

    * `ops_count`
    * `ops_invalid_count`
    * `ops_overflow_count`
      기록
* DoD

  * 60 주행에서 `ops_overflow_count = 0`
  * “EDIT+VERIFY”가 기본으로 들어가고, 3번째는 조건부 1개만 들어감

### Step 4) 60분: 어제 미해결 2개 처리(안 하면 계속 찝찝해서 폭주함)

어제 파일에 박제된 미해결이 2개 있음. 근거: `/mnt/data/12.28개발일지.txt` “발견된문제·원인”

1. **NEG_02 오탐(SANDBOX로 떨어짐)**

   * 목표: “부정문(없다/아니다)”을 과하게 위반으로 잡는 패턴 완화
   * DoD: guard 케이스 러너에서 NEG_02가 **기대값 PASS로 통과** 영수증
2. **MeterGuard: INVALID/INSUFFICIENT_EVIDENCE는 집계 제외 자동화**

   * 목표: “고장 난 샘플이 통계에 섞여서 법공장 오염” 방지
   * DoD: 리포트에 `excluded_invalid_meter_count` 같은 집계가 증가하고, 메인 집계에서 빠짐

### Step 5) 60분: 60 만차 1회 실주행(오늘의 최종 결재)

* 실행

  * (Step2에서 확장한 커맨드로) `--total_tasks 60`
* DoD(오늘 합격선)

  * 60 주행 영수증 1장
  * meter_tick 정상
  * ops_overflow 0
  * NEG_02 PASS
  * INVALID 집계 제외 동작 확인

---

## 3) 오늘 코스의 “결정적 이유” 한 줄

형아가 원하는 건 120이 아니라 **60을 매일 안정적으로 굴리는 체감 효율**이고, 그 체감 효율은 “속도 10%”가 아니라 **폭주/누락/재작업을 줄여서 생기는 시간 절약**에서 나옴. 그래서 µOP+검증이 필요함.

---

## 4) 설계 제안(확장 단계 규칙: A/B 둘 다)

### (A) 보수안(추천, 오늘 딱 이대로)

* 60부터 가되
* µOP 8개 고정 + workitem당 최대 3ops
* COMMIT은 VERIFY 없으면 금지
* NEG_02 + INVALID 집계 제외까지 오늘 같이 끝냄

### (B) 공격안(파괴력 우선)

* 60부터 가면서
* 3ops를 기본값으로 당김(EDIT+VERIFY+REPORT를 기본)
* ABORT를 적극 사용해서 폭주 조짐이면 바로 컷
* **이 설계는 위험하지만, 현재 단계에서는 감당 가능함.**
  위험한 이유: 3ops 기본이 습관되면 “4ops 욕심”이 다시 생기고, 그때 제미나이가 다시 멍청해질 확률이 올라감

---

## 5) 파괴력 있는 구조적 아이디어 1개(위험 포함)

### “SortLang 패킷(숫자 전보) + 영수증 포인터만 화면에 출력”

* 화면에 60개 텍스트를 다 뿌리지 말고,
* **숫자 패킷(작업ID/상태코드/µOP코드/파일포인터/증거포인터)**만 주고,
* 상세는 `writer_receipt_ptr` 같은 포인터 파일로 넘김

효과: 화면 출력량 급감 → 세션 덜 느려짐 → 운영 체감 빨라짐
위험: 사람이 눈으로 읽기 힘들어져서 “초기 디버그”는 더 답답할 수 있음(대신 너는 안 보니까 운영상 OK)

---

## 6) 오늘용 “하청지시서(복붙)” (제미나이에게 그대로 던지면 됨)

* 목표: run_bundle_v4를 60(12×5)로 확장 + µOP 8 코드북 + ops<=3 검증 + meter_tick 기록 + NEG_02 오탐 완화 + INVALID 집계 제외
* 제한:

  * 새 파일은 최대 3개까지만(가능하면 기존 파일 수정 우선)
  * 로그/영수증 포인터(writer_receipt_ptr) 유지
* 납품물(원하는 형태):

  1. 수정된 파일 경로 리스트
  2. 실행 커맨드 2개(24 기준점, 60 실주행)
  3. DoD 체크 결과(숫자 포함: subpacks, ops_overflow_count, excluded_invalid_meter_count)

(여기서 “정확히 어떤 파일이 룰 주입부냐” 같은 건 지금 증거가 부족하면, PowerShell `dir ... | findstr ...`로 먼저 찾고 경로를 리포트에 박아오라고 지시)

---

**치매방지 1줄(초딩버전)**
오늘은 “60개를 12개씩 5번에 나눠 실어 나르되, 버튼(µOP) 8개만 써서 일이 몰래 4개로 늘어나는 폭주를 막고, 어제 남은 오탐/집계오염까지 같이 정리하는 날”이다.





### ▶ 단계 판정

**[확장 단계]**

### ✅ 프로젝트 파일 우선 참조 근거 1줄

숫자/명령 DSL(허용된 동작만 노출해서 불법 호출 자체를 못 하게) 방향은 이미 문서에 있음: `/mnt/data/G6X_TOTAL_FINAL_V3.txt`의 “행동 명령 DSL(도메인 전용 언어)” 구간, 그리고 카드 묶음 템플릿은 `/mnt/data/g6x_cards_template_48.md`에 “카드 1줄+고정 필드”로 박혀있음.

형아가 원하는 건 “숫자 언어(SSOT) 확장 개념”을 **더 크게, 더 운영용으로** 다듬어서 “어떻게 만들고 어떻게 쓰는지” 풀출력이지?
아래가 내가 리딩하는 **SortLang(숫자언어) v1.1 운영 설계**야.

## 1) SortLang(숫자 언어) 한 문장 정의

**사람 말 대신 “숫자 코드 + 포인터”로만 하청을 주고받는 표준 운송체계.**
텍스트는 “내용 저장”이 아니라 “증거/영수증 파일”에만 두고, 채팅엔 최소 숫자만 남긴다.

## 2) 왜 이걸 하냐(목적 3개)

1. 폭주 방지
   할 수 있는 행동을 “정해진 코드”로만 하게 해서 2동작이 4동작으로 커지는 걸 못 하게 막음(µOP랑 찰떡)
2. 누락/섞임 방지
   후보/승인/차단 같은 단계가 섞이면 바로 INVALID로 격리 가능(라벨 계약이랑 찰떡)
3. 화면 출력량 절감
   48/60개를 글로 뿌리면 세션이 느려지는데, 숫자 패킷은 화면에 20줄로 끝낼 수 있음

## 3) SortLang 구성품(SSOT, “단일 진실” 3개)

### A. 코드북(SSOT) 1개

파일 1개만 진짜로 믿는다

* `engine/sortlang_codebook_v1.json` (권장 경로, 실제 경로는 형아 프로젝트에 맞춰 확정 필요: UNKNOWN)

코드북에 들어가는 것

* 상태코드(status): PASS/WARN/FAIL/BLOCK/INVALID
* 단계라벨(stage): CANDIDATE/RULE_READY/HARD
* µOP(action): EDIT/VERIFY/REPORT/SNAPSHOT/ROLLBACK/COMMIT/PLAN/ABORT (8개)
* 버킷(bucket): SPACE/TIME/STATE/PRONOUN/RULE 등
* 에러코드(err): NEG_02 같은 케이스 코드, SIG_* 등

핵심 규칙

* 코드북은 버전 올려도 **기존 코드를 절대 바꾸지 않는다**(추가만 한다)
* 숫자 범위를 예약한다(예: status 1~99, stage 100~199, action 200~299…)

### B. 패킷(운송장) 2종

* 작업 패킷: “이거 해”
* 결과 패킷: “했어/망했어/증거는 여기”

### C. 검증기(Validator) 1개

패킷이 이상하면 즉시 INVALID로 격리

* µOP 10개 금지
* workitem당 ops 최대 3
* HARD만 BLOCK 가능
* COMMIT은 VERIFY 없이 금지

## 4) 패킷 포맷(진짜 실전용, 짧고 튼튼)

형아가 “내가 읽을 필요 없음, 제미나이/너만 이해하면 됨”이니까
가독성보다 “짧고 파싱 쉬운” 쪽으로 간다.

### 4-1) 작업 패킷: `work_packet.tsv`

TSV 한 줄 = workitem 1개

필드(고정 10개)

1. v : 프로토콜 버전(예: 11)
2. run : run_id 숫자/짧은 문자열
3. wid : workitem id(1..60)
4. pri : 우선순위(1..9)
5. bucket : 버킷 코드(예: 301=RULE)
6. stage : 단계 코드(예: 101=CANDIDATE)
7. ops : µOP 시퀀스(예: 201,202 또는 201,202,203)
8. tgt : 대상 포인터(파일/경로 id)
9. dod : DoD 코드(검증 항목 id)
10. ev : 입력 증거 포인터(없으면 0)

예시(감 잡는 용)

* `11	RUN60A	7	5	301	101	201,202	9012	7001	0`
  뜻(사람말로 번역)
* v11, RUN60A, 7번 작업, 우선순위 5
* RULE 버킷, CANDIDATE 단계
* EDIT→VERIFY
* 타겟 포인터 9012, DoD 7001

### 4-2) 결과 패킷: `result_packet.tsv`

필드(고정 10개)

1. v
2. run
3. wid
4. status : 상태코드(예: 1=PASS, 2=WARN, 3=FAIL, 4=BLOCK, 9=INVALID)
5. drift : 드리프트 점수(없으면 -1)
6. stage_out : 처리 후 단계(예: 102=RULE_READY, 103=HARD)
7. ops_used : 실제 사용 ops(검증용)
8. out_ptr : 산출물 포인터(파일 id)
9. receipt_ptr : 영수증 포인터(writer_receipt_ptr 같은 것)
10. note : 짧은 에러/코드(NEG_02 등)

예시

* `11	RUN60A	7	2	14	102	201,202	9107	9301	NEG_02`
  뜻
* 7번 작업 WARN, drift 14, RULE_READY로 승격, 영수증은 9301, 주의 케이스 NEG_02

## 5) “어떻게 사용하냐” 운영 흐름(만차 60 기준)

형아가 합의한 “60부터” 기준으로 딱 박아줄게.

### Step 0. 준비물

* 코드북 1개(SSOT)
* work_packet.tsv 생성기(만차 러너가 만들게)
* result_packet.tsv 수집기(레저/영수증이 만들게)

### Step 1. 만차는 무조건 WIP=12로 자른다

* 총 60개여도 한 번에 60을 모델에게 다 주지 않는다
* 12개씩 5판으로 돌린다(12×5)

### Step 2. 한 판에 모델에게 주는 건 “work_packet 12줄”뿐

텍스트 설명 길게 금지

* 모델 입력: 12줄 숫자 패킷 + 코드북 버전 번호 1줄
* 모델 출력: 12줄 결과 패킷(또는 결과 JSONL)만

### Step 3. 상세 내용(수정 diff, 테스트 로그)은 전부 “영수증 파일”로 뺀다

채팅에 길게 붙이지 않는다

* 화면에는 TOP3 FAIL/WARN만 “짧게”
* 나머지는 포인터로만 남김

### Step 4. 라벨 계약과 결합

* CANDIDATE는 절대 BLOCK 못 함
* RULE_READY도 절대 BLOCK 못 함
* HARD만 BLOCK 가능
  이걸 검증기가 강제한다

## 6) µOP 8개(허용) / 10개 금지의 이유(운영 관점)

* 8개는 “공장에 필요한 버튼 + 폭주 방지 버튼(PLAN/ABORT)”까지 포함한 최소 세트
* 10개 넘어가면 “버튼 늘었다 → 선택지 늘었다 → 모델이 이것저것 눌러보다 폭주” 확률이 급상승
* 형아 목표가 60 안정 운영이면, 8개가 가장 이득/리스크 균형점

## 7) 확장 설계(나중에 라이트엔진/고용망/테스트까지 커버하려면)

형아가 말한 “지금 대충 만들지 말고 크게 설계”는 여기서 해결한다.

### 7-1) 코드 확장 규칙(절대 안 깨지는 규칙)

* 기존 코드 재정의 금지(번호 바꾸기 금지)
* 추가는 “예약 구간”에만 한다
* 버전 올릴 때는 v만 올리고, 구버전 파서도 읽게 한다

### 7-2) 필수로 예약해둘 범위

* bucket: 300~399
* stage: 100~199
* action(µOP): 200~299
* status: 1~99
* dod: 7000~7999 (검증 항목)
* ptr: 9000~999999 (포인터 id)

### 7-3) 포인터(ptr) 규격(중요)

포인터는 “파일/경로/스냅샷/영수증”을 가리킨다
포인터만으로도 작업이 재현돼야 한다(회귀 가능)

권장 포인터 타입

* receipt_ptr: writer_receipt jsonl
* out_ptr: 수정된 파일 diff/패치 묶음
* log_ptr: 테스트 로그
* snap_ptr: 스냅샷 해시

## 8) 오늘 합의(60부터, µOP 8) 기준으로 “바로 적용” 체크리스트

형아가 내일/오늘 밤에 바로 붙일 때 체크만 하면 됨

1. work_packet.tsv 60개 생성되나
2. 12개씩 5판으로 잘라 주나
3. result_packet.tsv에 wid 60개가 다 채워지나
4. ops가 3개를 넘으면 INVALID로 빠지나
5. stage가 HARD가 아닌데 BLOCK이 나오면 INVALID로 빠지나
6. 화면 출력은 TOP3만(나머지 포인터)로 줄었나

## 9) 이걸 쓰면 “속도 느려지냐” 정직한 답

* 한 판 실행 시간은 VERIFY/스냅샷 때문에 조금 늘 수 있음
* 그런데 형아가 싫어하는 “재작업/폭주/누락”이 줄어서 전체 체감은 빨라질 확률이 높다
  특히 60 운영에서는 “속도 10%”보다 “망해서 다시 하는 시간”이 훨씬 큼

## 10) 지금 당장 내가 더 개선해서 제안하는 것(파괴력 아이디어 1개, 위험 포함)

**ops를 “배열”이 아니라 “비트마스크”로 줄이는 방식**

* 예: EDIT=1, VERIFY=2, REPORT=4… 해서 ops=3이면 EDIT+VERIFY
* 장점: 더 짧아짐(패킷이 더 작아짐)
* 위험: 사람이 보기 더 어려움(그래도 형아는 안 보니까 운영상 OK, 대신 디버그 초반에 내가 더 힘들어짐)

## 11) UNKNOWN(증거 부족이라 확정 못 한 것)

* 형아 로컬에서 실제로 `engine/sortlang_codebook_v1.json`을 어디에 둘지, 어떤 모듈이 가장 먼저 읽을지
* 기존 `tools/run_bundle_v4.py`에 패킷 생성/수집을 어디에 끼울지(파일 확인 필요)

원하면 다음 세션 시작하자마자 내가 “프로젝트 파일 우선 참조”로 경로부터 딱 찍어서, 실제 삽입 지점까지 확정해줄게.

치매방지 1줄(초딩버전)
숫자 언어(SortLang)는 “코드북 1개 + 작업패킷/결과패킷 + 검증기”로 구성해서 60개를 12개씩 나눠 돌리면서 화면엔 숫자만 남기고, 폭주/누락은 규칙으로 INVALID 격리해 안 터지게 굴리는 표준 운송체계다.


### ▶ 단계 판정

**[확장 단계]**

### ✅ 프로젝트 파일 우선 참조 근거 1줄

숫자/명령 DSL(허용된 동작만 노출해서 불법 호출 자체를 못 하게) 방향은 이미 문서에 있음: `/mnt/data/G6X_TOTAL_FINAL_V3.txt`의 “행동 명령 DSL(도메인 전용 언어)” 구간, 그리고 카드 묶음 템플릿은 `/mnt/data/g6x_cards_template_48.md`에 “카드 1줄+고정 필드”로 박혀있음.

형아가 원하는 건 “숫자 언어(SSOT) 확장 개념”을 **더 크게, 더 운영용으로** 다듬어서 “어떻게 만들고 어떻게 쓰는지” 풀출력이지?
아래가 내가 리딩하는 **SortLang(숫자언어) v1.1 운영 설계**야.

## 1) SortLang(숫자 언어) 한 문장 정의

**사람 말 대신 “숫자 코드 + 포인터”로만 하청을 주고받는 표준 운송체계.**
텍스트는 “내용 저장”이 아니라 “증거/영수증 파일”에만 두고, 채팅엔 최소 숫자만 남긴다.

## 2) 왜 이걸 하냐(목적 3개)

1. 폭주 방지
   할 수 있는 행동을 “정해진 코드”로만 하게 해서 2동작이 4동작으로 커지는 걸 못 하게 막음(µOP랑 찰떡)
2. 누락/섞임 방지
   후보/승인/차단 같은 단계가 섞이면 바로 INVALID로 격리 가능(라벨 계약이랑 찰떡)
3. 화면 출력량 절감
   48/60개를 글로 뿌리면 세션이 느려지는데, 숫자 패킷은 화면에 20줄로 끝낼 수 있음

## 3) SortLang 구성품(SSOT, “단일 진실” 3개)

### A. 코드북(SSOT) 1개

파일 1개만 진짜로 믿는다

* `engine/sortlang_codebook_v1.json` (권장 경로, 실제 경로는 형아 프로젝트에 맞춰 확정 필요: UNKNOWN)

코드북에 들어가는 것

* 상태코드(status): PASS/WARN/FAIL/BLOCK/INVALID
* 단계라벨(stage): CANDIDATE/RULE_READY/HARD
* µOP(action): EDIT/VERIFY/REPORT/SNAPSHOT/ROLLBACK/COMMIT/PLAN/ABORT (8개)
* 버킷(bucket): SPACE/TIME/STATE/PRONOUN/RULE 등
* 에러코드(err): NEG_02 같은 케이스 코드, SIG_* 등

핵심 규칙

* 코드북은 버전 올려도 **기존 코드를 절대 바꾸지 않는다**(추가만 한다)
* 숫자 범위를 예약한다(예: status 1~99, stage 100~199, action 200~299…)

### B. 패킷(운송장) 2종

* 작업 패킷: “이거 해”
* 결과 패킷: “했어/망했어/증거는 여기”

### C. 검증기(Validator) 1개

패킷이 이상하면 즉시 INVALID로 격리

* µOP 10개 금지
* workitem당 ops 최대 3
* HARD만 BLOCK 가능
* COMMIT은 VERIFY 없이 금지

## 4) 패킷 포맷(진짜 실전용, 짧고 튼튼)

형아가 “내가 읽을 필요 없음, 제미나이/너만 이해하면 됨”이니까
가독성보다 “짧고 파싱 쉬운” 쪽으로 간다.

### 4-1) 작업 패킷: `work_packet.tsv`

TSV 한 줄 = workitem 1개

필드(고정 10개)

1. v : 프로토콜 버전(예: 11)
2. run : run_id 숫자/짧은 문자열
3. wid : workitem id(1..60)
4. pri : 우선순위(1..9)
5. bucket : 버킷 코드(예: 301=RULE)
6. stage : 단계 코드(예: 101=CANDIDATE)
7. ops : µOP 시퀀스(예: 201,202 또는 201,202,203)
8. tgt : 대상 포인터(파일/경로 id)
9. dod : DoD 코드(검증 항목 id)
10. ev : 입력 증거 포인터(없으면 0)

예시(감 잡는 용)

* `11	RUN60A	7	5	301	101	201,202	9012	7001	0`
  뜻(사람말로 번역)
* v11, RUN60A, 7번 작업, 우선순위 5
* RULE 버킷, CANDIDATE 단계
* EDIT→VERIFY
* 타겟 포인터 9012, DoD 7001

### 4-2) 결과 패킷: `result_packet.tsv`

필드(고정 10개)

1. v
2. run
3. wid
4. status : 상태코드(예: 1=PASS, 2=WARN, 3=FAIL, 4=BLOCK, 9=INVALID)
5. drift : 드리프트 점수(없으면 -1)
6. stage_out : 처리 후 단계(예: 102=RULE_READY, 103=HARD)
7. ops_used : 실제 사용 ops(검증용)
8. out_ptr : 산출물 포인터(파일 id)
9. receipt_ptr : 영수증 포인터(writer_receipt_ptr 같은 것)
10. note : 짧은 에러/코드(NEG_02 등)

예시

* `11	RUN60A	7	2	14	102	201,202	9107	9301	NEG_02`
  뜻
* 7번 작업 WARN, drift 14, RULE_READY로 승격, 영수증은 9301, 주의 케이스 NEG_02

## 5) “어떻게 사용하냐” 운영 흐름(만차 60 기준)

형아가 합의한 “60부터” 기준으로 딱 박아줄게.

### Step 0. 준비물

* 코드북 1개(SSOT)
* work_packet.tsv 생성기(만차 러너가 만들게)
* result_packet.tsv 수집기(레저/영수증이 만들게)

### Step 1. 만차는 무조건 WIP=12로 자른다

* 총 60개여도 한 번에 60을 모델에게 다 주지 않는다
* 12개씩 5판으로 돌린다(12×5)

### Step 2. 한 판에 모델에게 주는 건 “work_packet 12줄”뿐

텍스트 설명 길게 금지

* 모델 입력: 12줄 숫자 패킷 + 코드북 버전 번호 1줄
* 모델 출력: 12줄 결과 패킷(또는 결과 JSONL)만

### Step 3. 상세 내용(수정 diff, 테스트 로그)은 전부 “영수증 파일”로 뺀다

채팅에 길게 붙이지 않는다

* 화면에는 TOP3 FAIL/WARN만 “짧게”
* 나머지는 포인터로만 남김

### Step 4. 라벨 계약과 결합

* CANDIDATE는 절대 BLOCK 못 함
* RULE_READY도 절대 BLOCK 못 함
* HARD만 BLOCK 가능
  이걸 검증기가 강제한다

## 6) µOP 8개(허용) / 10개 금지의 이유(운영 관점)

* 8개는 “공장에 필요한 버튼 + 폭주 방지 버튼(PLAN/ABORT)”까지 포함한 최소 세트
* 10개 넘어가면 “버튼 늘었다 → 선택지 늘었다 → 모델이 이것저것 눌러보다 폭주” 확률이 급상승
* 형아 목표가 60 안정 운영이면, 8개가 가장 이득/리스크 균형점

## 7) 확장 설계(나중에 라이트엔진/고용망/테스트까지 커버하려면)

형아가 말한 “지금 대충 만들지 말고 크게 설계”는 여기서 해결한다.

### 7-1) 코드 확장 규칙(절대 안 깨지는 규칙)

* 기존 코드 재정의 금지(번호 바꾸기 금지)
* 추가는 “예약 구간”에만 한다
* 버전 올릴 때는 v만 올리고, 구버전 파서도 읽게 한다

### 7-2) 필수로 예약해둘 범위

* bucket: 300~399
* stage: 100~199
* action(µOP): 200~299
* status: 1~99
* dod: 7000~7999 (검증 항목)
* ptr: 9000~999999 (포인터 id)

### 7-3) 포인터(ptr) 규격(중요)

포인터는 “파일/경로/스냅샷/영수증”을 가리킨다
포인터만으로도 작업이 재현돼야 한다(회귀 가능)

권장 포인터 타입

* receipt_ptr: writer_receipt jsonl
* out_ptr: 수정된 파일 diff/패치 묶음
* log_ptr: 테스트 로그
* snap_ptr: 스냅샷 해시

## 8) 오늘 합의(60부터, µOP 8) 기준으로 “바로 적용” 체크리스트

형아가 내일/오늘 밤에 바로 붙일 때 체크만 하면 됨

1. work_packet.tsv 60개 생성되나
2. 12개씩 5판으로 잘라 주나
3. result_packet.tsv에 wid 60개가 다 채워지나
4. ops가 3개를 넘으면 INVALID로 빠지나
5. stage가 HARD가 아닌데 BLOCK이 나오면 INVALID로 빠지나
6. 화면 출력은 TOP3만(나머지 포인터)로 줄었나

## 9) 이걸 쓰면 “속도 느려지냐” 정직한 답

* 한 판 실행 시간은 VERIFY/스냅샷 때문에 조금 늘 수 있음
* 그런데 형아가 싫어하는 “재작업/폭주/누락”이 줄어서 전체 체감은 빨라질 확률이 높다
  특히 60 운영에서는 “속도 10%”보다 “망해서 다시 하는 시간”이 훨씬 큼

## 10) 지금 당장 내가 더 개선해서 제안하는 것(파괴력 아이디어 1개, 위험 포함)

**ops를 “배열”이 아니라 “비트마스크”로 줄이는 방식**

* 예: EDIT=1, VERIFY=2, REPORT=4… 해서 ops=3이면 EDIT+VERIFY
* 장점: 더 짧아짐(패킷이 더 작아짐)
* 위험: 사람이 보기 더 어려움(그래도 형아는 안 보니까 운영상 OK, 대신 디버그 초반에 내가 더 힘들어짐)

## 11) UNKNOWN(증거 부족이라 확정 못 한 것)

* 형아 로컬에서 실제로 `engine/sortlang_codebook_v1.json`을 어디에 둘지, 어떤 모듈이 가장 먼저 읽을지
* 기존 `tools/run_bundle_v4.py`에 패킷 생성/수집을 어디에 끼울지(파일 확인 필요)

원하면 다음 세션 시작하자마자 내가 “프로젝트 파일 우선 참조”로 경로부터 딱 찍어서, 실제 삽입 지점까지 확정해줄게.

치매방지 1줄(초딩버전)
숫자 언어(SortLang)는 “코드북 1개 + 작업패킷/결과패킷 + 검증기”로 구성해서 60개를 12개씩 나눠 돌리면서 화면엔 숫자만 남기고, 폭주/누락은 규칙으로 INVALID 격리해 안 터지게 굴리는 표준 운송체계다.
이방식으로 안했을거야 이방식으로 되겧해야한다.