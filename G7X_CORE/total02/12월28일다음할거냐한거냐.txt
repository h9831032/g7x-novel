According to a document from **2025-12-28**, 지금 상태는 **“통제 장치(사후 감리/봉인/회귀)는 이미 꽂혔고, ‘설계 때부터 자동 통제(사전 검문+원클릭 번들러)’는 아직 미완”**이 맞아. 근거로 이미 `audit_report_v1` 생성 + `seal_snapshot_v0.py PHASE2_FINAL` 봉인까지 찍혀있고(=사후 박제는 완료), 하네스 200턴 3회 동일 해시 PASS까지 확보돼 있어. 

---

## 🔎 단계 판정

**[확장 단계]**

---

## 1) “내일(8시간) 안에 끝나나?”

**끝내는 “대상”을 명확히 하면, 8시간 안에 ‘v1 최소형’은 끝낼 가능성이 높다.**
여기서 끝낸다는 뜻은 딱 이거야:

* **커맨드 1줄로**
  **Preflight(사전검문) → Harness → Audit → Regression → Seal Snapshot**
  이게 **자동으로 따라붙게** 만들기 (즉, 개노가다 반복 제거)

다만, **UNKNOWN 리스크**는 있어:

* 기존 코드가 “사람 손으로 실행”을 전제로 짜인 부분(환경변수/경로/옵션)이 있으면 번들러에서 삐끗할 수 있음. (이건 내일 바로 로그로 잡아서 고치면 됨)

---

## 2) 내일 공정 “정답 순서” (내가 리딩한다)

### 목표: “설계 때부터 통제”를 커널로 박는다 (사후가 아니라 사전)

### Step 0. 기준선 고정 확인 (먼저 안 하면 또 흔들림)

* **하네스 봉인 기준선**: 200턴 3회 동일 해시 PASS가 이미 있음
* **사후 봉인 기준선**: `PHASE2_FINAL` 스냅샷 봉인 경로가 이미 찍힘

이 두 개가 “뼈대(기준선)”이야. 내일 뭘 하든 이거 안 깨지게 간다.

---

### Step 1. SQL 폭주 “영구 금지”를 커널 규칙으로 재확인

문서에 이미 **`SQL_BAN_LOCKED = TRUE`**로 박아놨고, **GLOBAL BAN ORDER**도 선언돼 있음
→ 내일 작업 중 SQL/DB 제안 나오면 **그 자체가 실패 조건**이 되게 만든다(사전검문에서 컷).

---

### Step 2. “사전검문(Preflight)” 먼저 만든다 (이게 핵심)

**왜 먼저냐?**
번들러 만들기 전에 사전검문이 없으면, 또 러시아 인형처럼 중간에 누가 폭주해도 **돌리고 나서야** 알게 됨.

사전검문이 하는 일(초딩버전):

* “들어가면 안 되는 방(SQL/DB)” 문 열려고 하면 **문 앞에서 바로 잡아챔**
* “허용된 루트(run_bundle로만 실행)” 아니면 **실행 자체를 막음**

---

### Step 3. “원클릭 번들러(run_bundle)”로 반복 작업을 묶는다

번들러가 하는 일:

* Preflight 통과하면
* 하네스(짧게) 돌리고
* audit_report 남기고
* regression 돌려서 FP=0 확인하고
* seal_snapshot 박제까지 자동으로 가게 만든다

너가 말한 4개(explainability/ledger/audit/regression) “자동으로 따라붙게”의 정답이 이거야.
(이미 audit + snapshot 봉인은 존재하니, 이제 **“자동으로 묶는 실행 루트”**만 만들면 됨)

---

### Step 4. DoD(완료정의): 내일 끝났다고 말할 수 있는 조건

* `python tools/run_bundle_v1.py --bundle PHASE2_FINALIZE --run_id XXX`
  이 한 줄로 **끝까지 자동완주**
* 결과물로 **manifest(영수증)** 하나가 남음:
  `run_id, seed, turns, law_hash, audit_summary_path, regression_pass, snapshot_path`

---

## 3) 확장 단계 설계 제안 (A/B)

### (A) 보수안(안정성 우선) ✅ 내가 추천

* **Preflight + RunBundle 최소 v1**만 만든다
* 금지영역(SQL/DB) 차단 + 자동 1줄 실행 루트만 고정
* 장점: 실패 확률 낮고, 내일 바로 “개노가다 반복” 체감 감소

### (B) 공격안(파괴력 우선)

* **해시 화이트리스트 커널락(실행 시 파일 해시가 허용목록과 다르면 즉시 FAIL)**까지 올린다
* 장점: “바꾸면 무조건 걸림” 레벨
* 단점: 개발이 답답해질 수 있음(운영 복잡도↑)
* **이 설계는 위험하지만, 현재 단계에서는 감당 가능함.**

---

## 4) 파괴력 있는 구조 아이디어 1개(위험 포함)

### 🔥 “RunManifest = 모든 실행의 영수증”을 시스템 헌법으로

* 앞으로 어떤 실행이든 **manifest 1장**을 남기게 강제하면,
* 텍스트 기억이 아니라 **숫자/해시/경로**로 원인 추적이 된다.
* 위험: 초반엔 귀찮아 보임. 근데 이게 없으면 너가 말한 “나중엔 원인추적 불가” 지옥이 다시 옴.

---

## 5) (하청지시서) 내일 8시간 코스 — Gemini에 바로 던질 복붙

너 규칙대로 “하나만 내릴지, 같이 내릴지” 묻지 않고 내가 결정한다: **한 방에 묶어서 3개만 납품**(preflight + scope_lock + run_bundle). SQL 폭주 여지를 원천 차단.

```text
[ORDER] Design-Time Variant Control v1 (Preflight + RunBundle) — SQL 폭주 영구 금지

0) STOP
- SQL/SQLite/DB/TopManagement 관련 구현/제안/파일 생성 전부 금지 (SQL_BAN_LOCKED=TRUE 유지)
- 기존 Phase1.5(법 거버넌스/하네스/회귀/봉인) 코드 수정 금지
- 새 파일은 딱 3개만 허용(아래 목록 외 생성 금지)

1) 목표
커맨드 1줄로 자동 수행:
Preflight(사전검문) -> Harness -> Audit -> Regression -> Seal Snapshot
그리고 금지영역(SQL/DB) 시도는 “실행 전에” 즉시 FAIL.

2) 납품물(3개)
(1) engine/preflight_guard_v1.py
(2) engine/scope_lock_v1.json
(3) tools/run_bundle_v1.py

3) 근거(현재 시스템에 이미 존재하는 기준선)
- audit_report_v1 + seal_snapshot_v0.py PHASE2_FINAL 봉인 로그가 존재함.
- harness 200턴 3회 동일 해시 PASS 존재함.
(이 기준선 유지가 최우선)

4) DoD
- 아래 1줄 실행이 끝까지 자동완주:
  python tools/run_bundle_v1.py --bundle PHASE2_FINALIZE --run_id FINALIZE_001
- 결과로 bundle_manifest.json 생성:
  {run_id,bundle,seed,turns,law_hash,audit_summary_path,regression_pass,snapshot_path,ts}
- SQL/DB 금지 위반은 preflight에서 즉시 FAIL + 이유 1줄 출력

5) 제출 형식
- 3개 파일 전체 코드 + 실행 커맨드 3줄만 제출
- 다음 단계 제안 금지
```

---

원하면, 내일 시작하자마자 너는 그냥 이 순서대로만 치면 돼:

1. **기준선(하네스/봉인) 재확인**
2. **preflight 먼저**
3. **run_bundle로 원클릭 자동화**
4. **manifest 영수증으로 박제**

이렇게 가면 “개노가다 반복”이 진짜로 줄어든다.
