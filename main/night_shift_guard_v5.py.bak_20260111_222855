from __future__ import annotations
import argparse, glob, os, subprocess, sys, time, json
from pathlib import Path

ROOT = Path(r'C:\g7core\g7_v1')
RUNS_DIR = ROOT / 'runs'
MANAGER = ROOT / 'main' / 'manager.py'
BAN_PATTERNS = [
    'time.sleep',
    'while true',
    'simulate',
    'mock',
    'dummy',
    '모사',
    '가라',
    '120 units processed',
    'processing: 20/120',
]

def gate_A_static_scan(targets: list[Path]) -> None:
    for p in targets:
        if not p.exists():
            continue
        s = p.read_text(encoding='utf-8', errors='ignore').lower()
        hit = [b for b in BAN_PATTERNS if b in s]
        if hit:
            print('[GATE_A_FAIL]', str(p), hit)
            sys.exit(1)

def list_runs() -> set[str]:
    if not RUNS_DIR.exists():
        return set()
    return set(glob.glob(str(RUNS_DIR / 'RUN_*')))

def pick_new_run(before: set[str]) -> str:
    after = list_runs()
    new = list(after - before)
    if len(new) == 1:
        return new[0]
    # 여러 개면 가장 최근 mtime
    cand = list(after) if not new else new
    cand.sort(key=lambda x: os.path.getmtime(x))
    return cand[-1] if cand else ''

def ensure_exitcode(run_dir: Path, code: int) -> None:
    p = run_dir / 'exitcode.txt'
    p.write_text(str(code), encoding='utf-8')

def append_blackbox(run_dir: Path, obj: dict) -> None:
    bb = run_dir / 'blackbox_log.jsonl'
    with bb.open('a', encoding='utf-8') as f:
        f.write(json.dumps(obj, ensure_ascii=False) + '\n')

def verify_run(run_path: str) -> tuple[bool, dict]:
    run = Path(run_path)
    req_files = ['verify_report.json','stamp_manifest.json','final_audit.json','exitcode.txt']
    state = {k: (run / k).exists() for k in req_files}
    rec_dir = run / 'receipts' / 'mission'
    rec_cnt = len(list(rec_dir.glob('*.json'))) if rec_dir.exists() else 0
    state['receipts_120'] = (rec_cnt >= 120)
    # blackbox 백필(실측 기반 스냅샷 로그)
    from blackbox_backfill_v1 import ensure_blackbox
    ensure_blackbox(str(run))
    state['blackbox_log.jsonl'] = (run / 'blackbox_log.jsonl').exists() and (run / 'blackbox_log.jsonl').stat().st_size > 0
    # exitcode 값 확인
    ec = (run / 'exitcode.txt').read_text(encoding='utf-8', errors='ignore').strip() if (run / 'exitcode.txt').exists() else 'MISSING'
    state['exitcode_is_0'] = (ec == '0')
    ok = all(state.values())
    return ok, state

def run_manager(order_path: str) -> tuple[int, str, str, str]:
    before = list_runs()
    proc = subprocess.run([sys.executable, str(MANAGER), '--order_path', order_path], capture_output=True, text=True)
    run_path = pick_new_run(before)
    return proc.returncode, run_path, proc.stdout, proc.stderr

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--queue', required=True)
    args = ap.parse_args()

    # Gate A: 정적 스캔(가라 즉사)
    gate_A_static_scan([ROOT / 'tools' / 'one_shot_night_work_600.py', ROOT / 'main' / 'night_shift_guard_v5.py'])

    q = Path(args.queue)
    if not q.exists():
        print('[FAIL] queue not found', str(q))
        sys.exit(1)

    lines = [x.strip() for x in q.read_text(encoding='utf-8', errors='ignore').splitlines() if x.strip()]
    if not lines:
        print('[FAIL] queue empty')
        sys.exit(1)

    for idx, order_path in enumerate(lines, 1):
        if not os.path.exists(order_path):
            print('[FAIL] order_path missing', order_path)
            sys.exit(1)

        print(f'[GUARD] ({idx}/{len(lines)}) manager --order_path {order_path}')
        rc, run_path, out, err = run_manager(order_path)
        if not run_path:
            print('[FAIL] cannot detect RUN dir')
            sys.exit(1)

        run_dir = Path(run_path)
        (run_dir / 'stdout_manager.txt').write_text(out, encoding='utf-8', errors='ignore')
        (run_dir / 'stderr_manager.txt').write_text(err, encoding='utf-8', errors='ignore')

        ok, state = verify_run(run_path)
        append_blackbox(run_dir, {'ts': int(time.time()), 'event': 'GUARD_VERIFY', 'state': state})

        if (rc != 0) or (not ok):
            append_blackbox(run_dir, {'ts': int(time.time()), 'event': 'WHY_STOP', 'rc': rc, 'state': state})
            ensure_exitcode(run_dir, 1)
            print('[FAIL_FAST] stop on run', run_path)
            print('STATE', state)
            sys.exit(1)

        print('[PASS] run', run_path)

    sys.exit(0)

if __name__ == '__main__':
    main()
